# Python基础知识



> Python是非常容易上手的，他的基础知识非常容易掌握。如果曾经学习过C++或者是Java的可以非常快的结束基础内容的学习。后文将会经常出现与C++的对比内容。

> Python的代码读起来会比较接近英文，大可以英文的阅读方式来理解Python。

> Python是一个基于面向对象的语言，面向对象将会是掌握Python基础的核心。这会花上一番精力。不用慌张，我们并不着急学习面向对象的知识。

## 1 基础语法

### 1.1 标识符/变量名

Python相比其他语言大大放宽了对变量的命名要求。你可以使用非ASCII字符作为变量名，你甚至可以使用中文作为变量名（但是我并不建议你这么做）。

- 第一个字符必须是字母表中字母或下划线`_` 。
- 标识符的其他的部分由字母、数字和下划线组成。
- 标识符对大小写敏感。

### 1.2 保留字/关键字

在C++中49个关键字（如`if`，`for`等）无法被用于标识符。

同样，在Python中也有保留字无法被用于标识符。

``` Python
# 你可以使用如下代码来查看当前版本Python的保留字
import keyword
print(keyword.kwlist)
# ['False', 'None', 'True', '__peg_parser__', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield']
```

### 1.3 运算符

Python**多数**运算符和C++相同。

> 如果是初学者可以先跳过运算符这里，我们在后面会逐步学习运算符。
>
> 这里的内容主要是用来做参考。

#### 算术运算符

| 运算符 | 描述               |
| ------ | ------------------ |
| +      | 相加               |
| -      | 相减               |
| *      | 相乘               |
| /      | 除                 |
| %      | 取模               |
| \*\*     | 幂                 |
| //     | 取整除（返回整数） |

> 相比C++增加了`**`和`//`两个算术运算符
>
> ````python
> 2 ** 3 # 8，2的3次幂
> 9 // 2 # 4，求商向下取整
> ````

#### 比较运算符、

| 运算符 | 描述     |
| ------ | -------- |
| ==     | 相等     |
| !=     | 不等于   |
| >      | 大于     |
| <      | 小于     |
| >=     | 大于等于 |
| <=     | 小于等于 |

> 比较运算符均会返回比较结果（结果为真则返回True，否则返回False）
>
> ``` python
> a = (1 == 2) # a = False
> b = (1 != 2) # b = True
> c = 2
> d = 3
> e = (c > d) # e = False
> ```

#### 赋值运算符

| 运算符 | 描述                                  |
| ------ | ------------------------------------- |
| =      | 赋值                                  |
| +=     | 加法赋值（a += 1等价于a = a + 1）     |
| -=     | 减法赋值（a -= 1等价于a = a - 1）     |
| *=     | 乘法赋值（a *= 1等价于a = a * 1）     |
| /=     | 除法赋值（a /= 1等价于a = a / 1）     |
| \*\*=    | 幂赋值（a \*\*= 1等价于a = a \*\* 1） |
| //=    | 整除赋值（a //= 1等价于a = a // 1） |

#### 位运算符

| 运算符 | 描述     |
| ------ | -------- |
| &      | 按位与   |
| \|     | 按位或   |
| ^      | 按位异或 |
| ~      | 按位取反 |
| <<     | 左移动   |
| >>     | 右移动   |

#### 逻辑运算符

| 运算符 | 描述   |
| ------ | ------ |
| and    | 布尔与 |
| or     | 布尔或 |
| not    | 布尔非 |

#### 成员运算符

| 运算符 | 描述                                          |
| ------ | --------------------------------------------- |
| in     | 在指定序列中找到值返回True，否则返回False     |
| not in | 在指定序列中没有找到值返回True，否则返回False |

#### 身份运算符

| 运算符 | 描述                               |
| ------ | ---------------------------------- |
| is     | 判断两个标识符是否引用同一个对象   |
| is not | 判断两个标识符是不是引用自不同对象 |

### 1.4 运算符优先级（重要！）

和我们的四则运算逻辑相同，在计算机编程语言中运算符同样存在先后顺序

下表中运算符自上到下优先级依次降低

> 注意：`( )`的优先级最高，如果你确实无法明白你所写的式子的运算顺序，那就按照你需要的运算方式加括号
>
> ```python
> # 例如
> (1+2)*3**2
> # 可以写为
> (1+2)*(3**2)
> # 当你不清楚你写的东西运算顺序是否正确的时候加括号就可以了
> ```

| 运算符                          | 描述                                                   |
| :------------------------------ | :----------------------------------------------------- |
| **                              | 指数 (最高优先级)                                      |
| ~，+，-                         | 按位翻转, 一元加号和减号 (最后两个的方法名为 +@ 和 -@) |
| *，/，%，//                     | 乘，除，求余数和取整除                                 |
| +，-                            | 加法减法                                               |
| >>，<<                          | 右移，左移运算符                                       |
| &                               | 位 'AND'                                               |
| ^，\|                           | 位运算符                                               |
| <=，<，>，>=                    | 比较运算符                                             |
| ==，!=                          | 等于运算符                                             |
| =，%=，/=，//=，-=，+=，*=，**= | 赋值运算符                                             |
| is，is not                      | 身份运算符                                             |
| in，not in                      | 成员运算符                                             |
| not，and，or                    | 逻辑运算符                                             |

### 1.5 注释

在Python中单行注释使用`#`，多行注释使用`'''`或`"""`

> 注意：使用引号构成的多行注释实质是生成一个字符串

```python
# 单行注释
# 这也是单行注释

'''多行

   注释'''

"""多行

   注释"""
```

### 1.6 缩进（重要！）

Python不像C++和Java那样使用`{}`来标识代码块。

Python使用**缩进**来表示代码块，同一代码块中的代码必须具有相同的缩进。

Python严格要求缩进规范，如果缩进出错会导致代码逻辑错误。

一般使用一个Tab（四个空格）来作为一次缩进。

```python
# Python
a = 1
if a:
	print(2)
	if not a:
		print(3)
else:
	print(4)
```

上面这段Python代码等价与C++中

```C++
// C++
a = 1;
if (a) {
    cout << 2 << endl;
    if (!a) {
		cout << 3 << endl;
    }
}
else {
    cout << 4 << endl;
}
```

### 1.7 单行语句

语句结尾不需要任何符号进行表示

### 1.8 多行语句

当单行语句过长时，可以使用`\`来实现多行语句

```python
simple = a + \
		b + \
		c
# 等价于
simple = a + b + c
```

需要注意，如果是`()`、`[]`、`{}`中的语句，可以直接换行而不需要加`\`进行标识。

（挖个坑，为什么会这样将会在后面讲到）

```python
simple = [a, 
          b, 
          c]
# 等价于
simple = [a, b, c]
```

### 1.9 import

Python使用`import `和`from...import `来导入模块

如同其字面意思一样

`import moduleName`将导入整个模块

`from moduleName import function`将导入指定内容

可以写为`from moduleName import function1, function2, function3`来导入多个内容

可以写为`from moduleName import *`来导入模块的全部内容

> `import moduleName`和`from moduleName import *`的区别体现在调用上。
>
> 例如模块中有个函数为`function1`。
>
> 那么`import`方式引入时要使用`moduleName.function1`来调用。
>
> `from ... import *`方式引入可以直接使用`function1`调用

> 请尽量避免使用`from ... import *`的方式来导入全部内容。
>
> 这么做可能导致同名函数被覆盖，无法得知自己调用的函数究竟是哪一个。
>
> 比如Python中原有函数`round()`，在你用`from ... import *`导入的包中同样包含了一个有着其他功能的`round()`函数，那么在后续的代码中这个`round()`就会存在歧义。

``` python
import os
os.listdir("C://") # 需要使用moduleName.function的方式来调用

import requests
a = requests.Session() # 使用moduleName.function的方式调用requests库中Session

from requests import Session
b = Session() # 可以直接调用Session

# a和b都可生成一个Session对象，效果相同
```

## 2 基本数据类型

Python的变量**不需要**声明。

但是所有变量在被使用前必须被赋值，只有被赋值了这个变量才会被创建。

Python是一个**弱类型**型语言，它不会显式的对数据类型进行区分，你也不必在意你创建的这个变量是什么类型的。Python将变量与其对应在内存中的数据类型分离开来。在Python中变量就是变量，变量只是指向内存中数据的一个工具。变量可以被指向任何一个数据，任何一种数据。

> 这里仍旧挖个坑，在后面将会详细说明这是如何实现的以及与C++的区别

``` python
print(a) # 这个时候变量a并没有被创建，无法输出

# 可以使用type()函数查看变量类型
a = 1 # 变量a被创建，指向一个整形数据
type(a) # <class 'int'>

a = 1.2 
type(a) # <class 'float'>

a = "string"
type(a) # <class 'str'>
```

除了常规的单个变量赋值，在Python中也可以同时多个变量赋值

``` python
a = b = c = 1
```

Python中还可以给多个对象指定多个变量

```python
a, b, c = 1, 2, 3
# a = 1
# b = 2
# c = 3
```

### 2.1 数字类型

python中数字有四种类型：整数、布尔型、浮点数和复数。

但是你并不需要刻意去记住他们，你只需要知道在Python中有这四种类型的数字即可。

> 注意：Python中的数字和C++中的完全不同。Python中的数字是没有溢出一说的。int和float仅仅是用于区分是否有小数部分。在Python中可以姑且认为单个变量可以记录的数字范围为$(-∞, +∞)$。

- **int** (整数), 如 1, 只有一种整数类型 int，表示为长整型。
- **bool** (布尔), 如 True。
- **float** (浮点数), 如 1.23、3E-2
- **complex** (复数), 如 1 + 2j、 1.1 + 2.2j

```python
a = 1 # <class 'int'>
b = 1.2 # <class 'float'>
c = True # <class 'bool'>
d = 1 + 2j # <class 'complex'> 注意，复数中的实数部分和虚数部分均是float类型
```

除此之外，Python还可以使用十六进制和八进制表示整数

```python
a = 0x00A # a = 10
b = 0o11 # b = 9
```

### 2.2 字符串(str)

在Python中你将经常与字符串打交道。但不用担心，Python的字符串十分友好。

在Python中，单引号与双引号的使用效果完全相同。在Python中是没有单个字符概念的，只有字符串。

如`'G'`是等价于`"G"`的。

> C++中单引号指单个字符，双引号指字符串

在Python中转义符仍为`\`。反斜杠可以用来转义，使用r可以让反斜杠不发生转义。 如`r"this is a line with \n"`则`\n`会显示，并不是换行。同样`\\`可以仍然可以输出`\`。

Python中的字符串可以使用`+`进行连接，用`*`进行重复连接

前文提到的`'''`和`"""`可以用于构成多行组成的字符串

``` Python
a = 'abc'
b = "abc"
c = """abc
abc"""

a + b # abcabc
a * 3 # abcabcabc

# Python提供了一个len()函数用来获取序列的长度。当传入字符串时，将会返回字符串长度（字符数）
len(a) # 3
len(c) # 6
```

#### 2.2.1 字符串访问

字符串可以使用`[ ]`进行索引。

$string[x]$这样来进行索引。

字符串中的每个值对应一个索引，在Python中有两种索引方式：从头索引、从尾索引

从头索引：下标从0开始，从前向后

从尾索引：下标从-1开始，从后向前

```python
a = "abcdef"

# 给大家写下来方便对照
从尾索引：     -5     -4    -3     -2     -1
从头索引：	0	1	2	3	4
"abcdef"：	a	b	c	d	e

a[0] # a
a[3] # d
a[-1] # e
a[-2] # d
```

> 尽管字符串是可以被索引的，但是字符串是不可以被局部更改的（即赋值操作）。
>
> ```python
> a = "string"
> a[2] = "u" 
> # 上面的索引赋值是不被允许的，Python解释器会报错
> # TypeError: 'str' object does not support item assignment
> ```

#### 2.2.2 字符串截取

可以在索引上更进一步，不是索引其中的一个值，而是索引其中的一段，从而实现字符串的截取。

同样使用`[ ]`来进行索引截取

$variable[start : end : step]$，会截取下标范围为$[start, end)$的内容（请务必注意这个取值范围），$step$指明步长。

省略$start$的值代表从字符串的头开始。

省略$end$的值代表到字符串的尾结束。

省略$: step$部分则会去默认步长1。

这里你可以使用从头索引或者是从尾索引。但是请注意，**可以二者混用**。

让我们来举个栗子

```python
a = "StringIsEasy"

# 这里给大家写出来方便对照
# 从尾索引：-12   -11   -10   -9    -8       -7     -6    -5    -4    -3     -2     -1
# 从头索引：	0	1	2	3	4	  5	     6	 7	 8	  9     10    11	
# a	      ：      S	  t	     r	   i       n	g	I	s	E	a	s	y

a[1 : 2] # t
a[ : 3] # Str
a[1 : ] # tringIsEasy
a[-3 : -1] # as
a[-3 : ] # asy
a[1 : -1] # tringIsEas
a[0 : 4 : 2] # Sr
a[1 : 5 : 2] # ti
a[-5 : -1 : 2] # sa
```

#### 2.2.3 Python中的转义字符

> 不需要全部记下，记下常用的即可。其他有需要可以直接去查文档。

| 转义字符     | 描述                                                         |
| :----------- | :----------------------------------------------------------- |
| \\(在行尾时) | 续行符【其实就是前面讲到的多行语句】                         |
| \\\（常用）  | 反斜杠符号                                                   |
| \\'（常用）  | 单引号                                                       |
| \\"（常用）  | 双引号                                                       |
| \a           | 响铃                                                         |
| \b（常用）   | 退格（Backspace）                                            |
| \000         | 空                                                           |
| \n（常用）   | 换行                                                         |
| \v           | 纵向制表符（非常不常用）                                     |
| \t（常用）   | 横向制表符（Tab）                                            |
| \r（常用）   | 回车，将 **\r** 后面的内容移到字符串开头，并逐一替换开头部分的字符，直至将 **\r** 后面的内容完全替换完成。 |
| \f           | 换页                                                         |
| \yyy         | 八进制数，y 代表 0~7 的字符，例如：\012 代表换行。           |
| \xyy         | 十六进制数，以 \x 开头，y 代表的字符，例如：\x0a 代表换行    |
| \other       | 其它的字符以普通格式输出                                     |

> 这里讲到了对引号和单引号的转义。
>
> 在Python中有种写法可以让大家在字符串中直接写引号
>
> 如果你的字符串中包含单引号，使用双引号包裹字符串
>
> 如果包含双引号，使用单引号包裹字符串
>
> 如果两者都有，使用三引号包裹字符串（什么？你问三引号是啥？就是前面提到的`"""`和`'''`）
>
> 当然我不推荐这么做，我个人建议在写代码的时候统一使用一种引号包裹字符串，该转义的就转义，不要怕麻烦，良好的代码习惯很重要。

#### 2.2.4 字符串格式化

和C++一样，Python同样支持字符串格式化。

在Python中有两种格式化字符串的方式。

> 注意：Python中的字符串格式化并不局限于输出，只要表达式正确任何时候都可以对字符串进行格式化

##### 类C++格式化

> 这种格式化方式是最严格的，但是比较繁琐。是否使用可以根据个人喜好以及应用需求来决定。

这种字符串格式化的方式和C++的`printf()`用法是相同的

```python
a = "String %s Easy %d"%("Is", 200)
# a = "String Is Easy 200"
```

我们称出现在字符串中的`%s`、`%d`为格式化符号，他们按照出现的顺序一一对应后面括号中的值。例如`%s`对应`"Is"`， `%d`对应`200`

不同的格式化符号对应不同类型的值。例如`%s`对应字符串，`%d`对应整型数值。之后的表会详细说明每一种格式化符号对应的数据类型。

如果格式化符号与对应数据的数据类型不相同的话会抛出错误。

| 符  号 | 描述                                 |
| :----- | :----------------------------------- |
| %c     | 格式化字符及其ASCII码                |
| %s     | 格式化字符串                         |
| %d     | 格式化整数                           |
| %u     | 格式化无符号整型                     |
| %o     | 格式化无符号八进制数                 |
| %x     | 格式化无符号十六进制数               |
| %X     | 格式化无符号十六进制数（大写）       |
| %f     | 格式化浮点数字，可指定小数点后的精度 |
| %e     | 用科学计数法格式化浮点数             |
| %E     | 作用同%e，用科学计数法格式化浮点数   |
| %g     | %f和%e的简写                         |
| %G     | %f 和 %E 的简写                      |
| %p     | 用十六进制数格式化变量的地址         |

我们还有一些操作符用来辅助格式化符号

| 符号  | 功能                                                         |
| :---- | :----------------------------------------------------------- |
| *     | 定义宽度                                                     |
| -     | 用做左对齐                                                   |
| +     | 在正数前面显示加号( + )                                      |
| <sp>  | 在正数前面显示空格                                           |
| #     | 在八进制数前面显示零('0')，在十六进制前面显示'0x'或者'0X'(取决于用的是'x'还是'X') |
| 0     | 显示的数字前面填充'0'而不是默认的空格                        |
| %     | '%%'输出一个单一的'%'                                        |
| (var) | 映射变量(字典参数)                                           |
| .n    | n 是小数点后的位数(如果可用的话)                             |

我们着重讲一下最后一种，这种是最常用的。

``` python
a = 1.23456789
"%f"%(a) # 1.2345689
"%.1f" # 1.2，这里.1指仅输出到小数点后一位
"%.5f" # 1.23456，输出到小数点后5位
"%.10f" # 1.2345678900，输出到小数点后10位，不存在的部分用0补齐
```

> 看到这里你肯定想问如果我想让字符串可以输出一个`%`怎么办。上面的操作符中存在一个`%`，你只需要书写`%%`即可让字符串在输出时有一个`%`，这点和转义符`\`相同（`\\`可以输出`\`）。

##### `str.format()`格式化方式

`format()`是字符串的一个方法。它可以被用于格式化字符串。它的灵活程度远高于前面提到的方法。

- 基础用法

我们只需要使用`{ }`在字符串中留下空位即可。这时候会按照出现的先后顺序依次将`format`中的值依次填入。

```python
"{ } is { }".format("string", "easy") # "string is easy"
```

我们也可以自己确定填入的顺序，这时候只需要在`{ }`中加入索引即可。这个索引来自于`format`，`format`会为接收到的值从0开始依次编号。

```python
"{0} is {1}".format("string", "easy") # "string is easy"
"{1} is {0}".format("string", "easy") # "easy is string"
# 而且这个时候可以让一个值在字符串中被使用多次
"{0} and {0} is {1}".format("string", "easy") # "string and string is easy"
"{1} and {0} is {1}".format("string", "easy") # "easy and string is easy"
```

我们甚至可以将我们的值参数化，让他们作为参数被填入字符串中。

```python
# 直接构建参数
"{n} is {adj}".format(n="string", adj="easy") # "string is easy"

# 构建字典 -----> 有关字典的详细内容请见后面，这里不会详解，如果不懂可以先跳过
word = {
    "n" = "string",
    "adj" = "easy"
}
"{n} is {adj}".format(word) # "string is easy"

# 使用列表索引 -----> 有关列表的详细内容见后面，这里不会详解，如果不懂可以先跳过
word = ["string", "easy"]
"{ 0[0] } is { 0[1] }".format(word) # "string is easy"
```

既然我们可以使用参数化的值，我们同样可以为`format`传入对象。**（这会涉及到面向对象相关知识，可以先了解一下）**

```python
class Value:
    def __init__(self):
        self.value = 66666

test = Value()
"My brain is { 0.value }".format(test)
```

- 数字格式化

有关数字格式化，这点基本继承了前面讲到的类C++格式化中的数字格式化方式，但是需要将`%`替换为`:`

```python
a = 1.23456789
"{ :.4f }".format(a) # 1.2345
```

详细格式如下

| 数字       | 格式    | 输出      |
| :--------- | :------ | :-------- |
| 3.1415926  | {:.2f}  | 3.14      |
| 3.1415926  | {:+.2f} | +3.14     |
| -1         | {:+.2f} | -1.00     |
| 2.71828    | {:.0f}  | 3         |
| 5          | {:0>2d} | 05        |
| 5          | {:x<4d} | 5xxx      |
| 10         | {:x<4d} | 10xx      |
| 1000000    | {:,}    | 1,000,000 |
| 0.25       | {:.2%}  | 25.00%    |
| 1000000000 | {:.2e}  | 1.00e+09  |
| 13         | {:>10d} | 13        |
| 13         | {:<10d} | 13        |
| 13         | {:^10d} | 13        |

其中`>`、`<`、`^`分别为右对齐、左对齐和居中对齐，对齐时所使用的填充字符根据其前面的符号决定。例如`{:x<4d}`会使用`x`进行填充。

#### 2.2.5 字符串下常用方法

> 这里仅仅作为文档参考，看不看都行，用到的时候会详细讲。

| 序号 | 方法及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | capitalize() 将字符串的第一个字符转换为大写                  |
| 2    | center(width, fillchar) 返回一个指定的宽度 width 居中的字符串，fillchar 为填充的字符，默认为空格。 |
| 3    | count(str, beg= 0,end=len(string)) 返回 str 在 string 里面出现的次数，如果 beg 或者 end 指定则返回指定范围内 str 出现的次数 |
| 4    | bytes.decode(encoding="utf-8", errors="strict") Python3 中没有 decode 方法，但我们可以使用 bytes 对象的 decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 |
| 5    | encode(encoding='UTF-8',errors='strict') 以 encoding 指定的编码格式编码字符串，如果出错默认报一个ValueError 的异常，除非 errors 指定的是'ignore'或者'replace' |
| 6    | endswith(suffix, beg=0, end=len(string)) 检查字符串是否以 obj 结束，如果beg 或者 end 指定则检查指定的范围内是否以 obj 结束，如果是，返回 True,否则返回 False. |
| 7    | expandtabs(tabsize=8) 把字符串 string 中的 tab 符号转为空格，tab 符号默认的空格数是 8 。 |
| 8    | find(str, beg=0, end=len(string)) 检测 str 是否包含在字符串中，如果指定范围 beg 和 end ，则检查是否包含在指定范围内，如果包含返回开始的索引值，否则返回-1 |
| 9    | index(str, beg=0, end=len(string)) 跟find()方法一样，只不过如果str不在字符串中会报一个异常。 |
| 10   | isalnum() 如果字符串至少有一个字符并且所有字符都是字母或数字则返 回 True，否则返回 False |
| 11   | isalpha() 如果字符串至少有一个字符并且所有字符都是字母或中文字则返回 True, 否则返回 False |
| 12   | isdigit() 如果字符串只包含数字则返回 True 否则返回 False..   |
| 13   | islower() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是小写，则返回 True，否则返回 False |
| 14   | isnumeric() 如果字符串中只包含数字字符，则返回 True，否则返回 False |
| 15   | isspace() 如果字符串中只包含空白，则返回 True，否则返回 False. |
| 16   | istitle() 如果字符串是标题化的(见 title())则返回 True，否则返回 False |
| 17   | isupper() 如果字符串中包含至少一个区分大小写的字符，并且所有这些(区分大小写的)字符都是大写，则返回 True，否则返回 False |
| 18   | join(seq) 以指定字符串作为分隔符，将 seq 中所有的元素(的字符串表示)合并为一个新的字符串 |
| 19   | len(string) 返回字符串长度                                   |
| 20   | [ljust(width, fillchar]) 返回一个原字符串左对齐,并使用 fillchar 填充至长度 width 的新字符串，fillchar 默认为空格。 |
| 21   | lower() 转换字符串中所有大写字符为小写.                      |
| 22   | lstrip() 截掉字符串左边的空格或指定字符。                    |
| 23   | maketrans() 创建字符映射的转换表，对于接受两个参数的最简单的调用方式，第一个参数是字符串，表示需要转换的字符，第二个参数也是字符串表示转换的目标。 |
| 24   | max(str) 返回字符串 str 中最大的字母。                       |
| 25   | min(str) 返回字符串 str 中最小的字母。                       |
| 26   | [replace(old, new , max]) 把 将字符串中的 old 替换成 new,如果 max 指定，则替换不超过 max 次。 |
| 27   | rfind(str, beg=0,end=len(string)) 类似于 find()函数，不过是从右边开始查找. |
| 28   | rindex( str, beg=0, end=len(string)) 类似于 index()，不过是从右边开始. |
| 29   | [rjust(width,, fillchar]) 返回一个原字符串右对齐,并使用fillchar(默认空格）填充至长度 width 的新字符串 |
| 30   | rstrip() 删除字符串末尾的空格或指定字符。                    |
| 31   | split(str="", num=string.count(str)) 以 str 为分隔符截取字符串，如果 num 有指定值，则仅截取 num+1 个子字符串 |
| 32   | [splitlines(keepends]) 按照行('\r', '\r\n', \n')分隔，返回一个包含各行作为元素的列表，如果参数 keepends 为 False，不包含换行符，如果为 True，则保留换行符。 |
| 33   | startswith(substr, beg=0,end=len(string)) 检查字符串是否是以指定子字符串 substr 开头，是则返回 True，否则返回 False。如果beg 和 end 指定值，则在指定范围内检查。 |
| 34   | [strip(chars]) 在字符串上执行 lstrip()和 rstrip()            |
| 35   | swapcase() 将字符串中大写转换为小写，小写转换为大写          |
| 36   | title() 返回"标题化"的字符串,就是说所有单词都是以大写开始，其余字母均为小写(见 istitle()) |
| 37   | translate(table, deletechars="") 根据 str 给出的表(包含 256 个字符)转换 string 的字符, 要过滤掉的字符放到 deletechars 参数中 |
| 38   | upper() 转换字符串中的小写字母为大写                         |
| 39   | zfill (width) 返回长度为 width 的字符串，原字符串右对齐，前面填充0 |
| 40   | isdecimal() 检查字符串是否只包含十进制字符，如果是返回 true，否则返回 false。 |

### 2.3 列表(list)

在使用Python的过程中，列表将会经常出现，你会**十分依赖**列表。

Python的列表属于广义表，它可以包含任何数据类型元素，它可以嵌套包含，它的长度是动态的。

Python的列表使用`[ ]`来包裹，在列表内使用`,`来分割元素。

Python的列表同样可以进行索引，使用`[ ]`进行索引和截取（这点十分类似我们前面所讲的字符串）。

列表同样支持从头索引和从尾索引。而且可以二者混用。

$List[pos]$

$List[start : end : step]$

```python
a = ["a", 1, "t", 1.2, [1, 2]]

# 这里构造了一个列表
从尾索引：     -5     -4    -3     -2      -1
从头索引：	0	1	2	3	 4
	a   ： [   "a"     1	   "t"	1.2	 [1,2]    ]

# 索引会返回对应元素
a[1] # 1
a[2] # "t"
a[4] # [1, 2]

# 截取的话将会返回列表
a[ : 2] # ["a", 1]
a[-3 : ] # ["t", 1.2, [1, 2]]
a[1 : -1] # [1, "t", 1.2]

# 与字符串不同的是，列表是可以进行索引赋值实现部分内容更改的
a[2] = 2.5 # a = ["a", 1, 2.5, 1.2, [1, 2]]

# 在字符串时我们提到的len()函数，同样可以用在列表上用来获取列表中的元素个数
len(a) # 5
len(a[4]) # 2，这时候是获取a中索引为4的元素的长度，这个元素是列表[1,2]，它的长度是2
```

同样的，使用`+`可以实现两个列表的连接；`*`可以实现列表的重复连接。

```python
a = [1, 2, 3]
b = [4, 5, 6]
a + b # [1, 2, 3, 4, 5, 6]
a * 2 # [1, 2, 3, 1, 2, 3]
```

前面我们提到列表是动态的，我们可以使用列表的`append()`方法和`pop()`方法来增删元素。

```python
# list.append(Element)
a = [1, 2, 3]
a.append("a") # a = [1, 2, 3, "a"]
# list.pop( position=-1 )
# pop()方法的默认会返回最后一个元素并在列表中删除，可以传入索引来删除特定位置的元素
a.pop() # a = [1, 2. 3]
a.pop(0) # a = [2, 3]
```

同样，我们也在这里列出列表的常用方法。

| 序号 | 方法                                                         |
| :--- | :----------------------------------------------------------- |
| 1    | list.append(obj) 在列表末尾添加新的对象                      |
| 2    | list.count(obj) 统计某个元素在列表中出现的次数               |
| 3    | list.extend(seq) 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） |
| 4    | list.index(obj) 从列表中找出某个值第一个匹配项的索引位置     |
| 5    | list.insert(index, obj) 将对象插入列表指定位置               |
| 6    | [list.pop(index=-1]) 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值 |
| 7    | list.remove(obj) 移除列表中某个值的第一个匹配项              |
| 8    | list.reverse() 反向列表中元素                                |
| 9    | list.sort( key=None, reverse=False) 对原列表进行排序         |
| 10   | list.clear() 清空列表                                        |
| 11   | list.copy() 复制列表                                         |

### 2.4 元组(tuple)

元组使用`( )`进行包裹，使用`,`分割元素。元组也是广义表，元组的几乎所有的特性均与列表相同，但是元组一旦被创建，其元素就不可以被改变，这点和字符串很像。

```python
# 注意，创建元组时，如果元组的元素只有一个，也要加,
# 这点与列表不同
# 如果不加,会被认为是运算
t = (1) # <class "int">
t = (1, ) # <class "tuple">

a = ("a", 1, "t", 1.2, [1, 2])

# 这里构造了一个列表
从尾索引：     -5     -4    -3     -2      -1
从头索引：	0	1	2	3	 4
	a   ： (   "a"     1	   "t"	1.2	 [1,2]    )

# 索引会返回对应元素
a[1] # 1
a[2] # "t"
a[4] # [1, 2]

# 截取的话将会返回列表
a[ : 2] # ()"a", 1)
a[-3 : ] # ()"t", 1.2, [1, 2])
a[1 : -1] # (1, "t", 1.2)

# 在字符串时我们提到的len()函数，同样可以用在列表上用来获取列表中的元素个数
len(a) # 5
len(a[4]) # 2，这时候是获取a中索引为4的元素的长度，这个元素是列表[1,2]，它的长度是2
```

我们仍然可以使用`+`来连接两个元组来构成一个新元组，使用`*`来重复连接一个元组

```python
a = (1, 2, 3)
b = (4, 5, 6)

a + b # (1, 2, 3, 4, 5, 6)
a * 2 # (1, 2 ,3, 1, 2, 3)
```

### 2.5 字典(dict)

字典使用`{ }`包裹，使用`,`来分割元素。与列表和元组不同的是，这里的每个元素都是一个键值对。

> Python的字典格式完全照搬json数据格式，如果你了解json数据格式的话这里可以快速浏览一下。

#### 2.5.1 键值对

键值对由键(key)和值(value)组成，通过`:`进行连接。

一般形式为$key : value$。

#### 2.5.2 组成字典

一个字典由若干组键值对组成。值(value)可以为任何数据类型，任何数据内容。但是键(key)的数据内容必须是唯一的，而且一般约定键的数据类型必须为字符串（数字也是可以被作为键，但是一般不会使用。除此之外的数据类型不被允许作为键）。

```python
a = {
    "str" : "string", # 一个键值对
    "num" : 1000,
    "list" : [1, 2],
    "tuple" : (1, 2),
    "dict" : { 
        "num" : 10000 # 注意：这里重新构成了一个字典，所以这个键值对与上面那个键也为num的键值对不冲突
    }
}

# 这里进行一个错误举例
b = {
    "str" : "string",
    [1000] ：1000, # 错误，键数据类型出错
    "str" : "test", # 错误，键的数据内容不唯一
}
```

#### 2.5.3 字典的索引与增删

字典可以索引，但是无法截取。

字典的索引和前述的方式并不相同，虽然它仍然使用`[ ]`进行索引，但它使用键作为索引的值。

```python
a = {
    "str" : "string", # 一个键值对
    "num" : 1000,
    "list" : [1, 2],
    "tuple" : (1, 2),
    "dict" : { 
        "num" : 10000 # 注意：这里重新构成了一个字典，所以这个键值对与上面那个键也为num的键值对不冲突
    }
}

a["str"] # "string"
a["list"] # [1, 2]

# 如果你索引了一个并不存在的键并试图获取它那薛定谔的值的时候，那么Python会抛出异常
a["undefined"] # KeyError: 'undefined'

# 同样可以len()函数来获取字典的长度，但是我也不是很清楚你这么做有啥实际意义emmmm
len(a) # 5
```

字典可以动态的增删元素，修改键值对的值

```python
a = {
    "str" : "string", # 一个键值对
    "num" : 1000,
    "list" : [1, 2],
    "tuple" : (1, 2),
    "dict" : { 
        "num" : 10000 # 注意：这里重新构成了一个字典，所以这个键值对与上面那个键也为num的键值对不冲突
    }
}

# 当你对已有的键进行索引并进行赋值时，即修改了这个键值对的值
a["str"] = "not string" # 原有的键值对"str":"string"变为"str":"not string"

# 当你对不存在的键进行索引并进行赋值时，即新建了这个键值对
a["new"] = "create" # 在字典中新增键值对"new":"create"

# 注意字典不能使用+进行连接，也不能使用*进行重复连接
```

#### 2.5.5 字典常用方法

| 序号 | 函数及描述                                                   |
| :--- | :----------------------------------------------------------- |
| 1    | radiansdict.clear() 删除字典内所有元素                       |
| 2    | radiansdict.copy() 返回一个字典的浅复制                      |
| 3    | radiansdict.fromkeys() 创建一个新字典，以序列seq中元素做字典的键，val为字典所有键对应的初始值 |
| 4    | radiansdict.get(key, default=None) 返回指定键的值，如果键不在字典中返回 default 设置的默认值 |
| 5    | key in dict 如果键在字典dict里返回true，否则返回false        |
| 6    | radiansdict.items() 以列表返回一个视图对象                   |
| 7    | radiansdict.keys() 返回一个视图对象                          |
| 8    | radiansdict.setdefault(key, default=None) 和get()类似, 但如果键不存在于字典中，将会添加键并将值设为default |
| 9    | radiansdict.update(dict2) 把字典dict2的键/值对更新到dict里   |
| 10   | radiansdict.values() 返回一个视图对象                        |
| 11   | [pop(key,default]) 删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。 |
| 12   | popitem() 随机返回并删除字典中的最后一对键和值。             |

### 2.6 集合

> 集合用的并不多。但是因为它的特性的原因，在某些特定环境下有很大的用途。

集合使用`{ }`或`set()`来创建，创建空集合必须使用`set()`而不能用`{ }`，`{ }`用于创建空字典。**请务必区分字典和集合。**

> 集合的元素可以是任何数据，字典必须是键值对

集合是一个**无序**的**不重复**元素序列。

集合通常可以用于去重判断。

```python
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'} 
# {'orange', 'banana', 'pear', 'apple'}，这是basket实际的内容，重复的元素仅会被保留一个

# 在很久之前的1.3节的成员运算符中我们提到过in和not in运算符就可以用在这里（不限于这里）
# in用来判断一个元素是否存在于当前序列中
# not in 用来判断一个元素是否不存在于当前序列中
"apple" in basket # True
"peach" in basket # False

# 同样可以使用len()函数获取集合的长度
len(basket) # 4
```

使用`add()`方法为集合添加元素（仍然会进行去重操作）

使用`remove()`方法从集合中移除元素（如果元素不存在会抛出异常）

集合的常用方法

| 方法                          | 描述                                                         |
| :---------------------------- | :----------------------------------------------------------- |
| add()                         | 为集合添加元素                                               |
| clear()                       | 移除集合中的所有元素                                         |
| copy()                        | 拷贝一个集合                                                 |
| difference()                  | 返回多个集合的差集                                           |
| difference_update()           | 移除集合中的元素，该元素在指定的集合也存在。                 |
| discard()                     | 删除集合中指定的元素                                         |
| intersection()                | 返回集合的交集                                               |
| intersection_update()         | 返回集合的交集。                                             |
| isdisjoint()                  | 判断两个集合是否包含相同的元素，如果没有返回 True，否则返回 False。 |
| issubset()                    | 判断指定集合是否为该方法参数集合的子集。                     |
| issuperset()                  | 判断该方法的参数集合是否为指定集合的子集                     |
| pop()                         | 随机移除元素                                                 |
| remove()                      | 移除指定元素                                                 |
| symmetric_difference()        | 返回两个集合中不重复的元素集合。                             |
| symmetric_difference_update() | 移除当前集合中在另外一个指定集合相同的元素，并将另外一个指定集合中不同的元素插入到当前集合中。 |
| union()                       | 返回两个集合的并集                                           |
| update()                      | 给集合添加元素                                               |

## 3 条件控制与循环

### 3.1 条件控制

条件控制通常用来实现下面这个流程图。

```flow
start=>start: 开始
condition=>condition: 条件
input=>inputoutput: 输入
operation=>operation: 条件代码
output=>inputoutput: 输出
error=>operation: 请重新输入
end=>end: 结束

start->condition
condition(no)->end
condition(yes)->operation->end
```

在Python中仅提供了`if`来实现条件控制

> 在Python中是没有`switch`的

#### 3.1.1 if语句

Python中的`if`语句块如下所示

```python
if condition1 :
    <statement>
elif condition2 :
    <statement>
else :
    <statement>
```

其中`elif`和`else`是可选的。

> 注意：通过`:`来表明后面将会跟随条件满足时要执行的代码块。必须严格满足缩进。

这里给出一段示例：

```python
a = 1
b = 2

if a > b :
    print("a>b")
elif b > a :
    print("b>a")
else :
    print("b==a")
# 最后的结果为："b>a"
```

#### 3.1.2 常用判断操作符

我们在[1.3节](# 1.3 运算符)中讲到的比较运算符和逻辑运算符会是这里的常客，成员运算符也经常会出现

可以给大家举点栗子

```python
a = 1
b = 2
c = 3
d = 1
e = [1, 2, 3, 4, 5]

if (a > b) and (a == d) : # 当a大于b且a等于d时进入代码块
    print("a")
elif (b > a) and (a == c) :
    print("b")
elif c in e: # 如果c在序列e中，进入代码块
    print("c")
else :
    print("d")
# 运行结果："c"
```

> 这里并没有说明逻辑运算符`or`。不管你有没有学过C++我都要说一嘴。
>
> 进行逻辑判断时是在遵循括号顺序的前提下从左向右依次执行。
>
> 比如`(1 < 2) or (1 == 2)`，那么会先判断`1 < 2`，再判断`1 == 2`。
>
> 从逻辑与与逻辑或的真值表上我们可以知道，只有全为真逻辑与才为真，只有全为假逻辑或才为假。
>
> 那么对于解释器来说，只要逻辑与碰到一个假即可判定整个条件为假，只要逻辑或碰到一个真即可判定整个条件为真。这样做可以加快执行速度。
>
> 简单的说，只要我们碰上一个可以完全确定整个式子真值的条件时，后续的条件判断均不会被执行。
>
> 用上面的那个例子，我们已经判断出`(1 < 2)`为真了，对于逻辑与来说整体已经为真了，这个时候后面第二个条件就不会被执行而直接返回真。
>
> 下面这个例子可以更好的说明这个特性。
>
> ```python
> a = [1, 2]
> b = 2
> if (a[0] < b) or (a.pop()) :
>     print("success")
> print(a) # [1, 2]
> ```
>
> 毫无疑问一定会输出success的，那么a的值呢？
>
> 如果一步不落的执行的话，a应该仅有一个元素`1`。但是当我们真实去运行程序的时候我们会发现，a中仍有两个元素，也是就说，`a.pop()`这句话并没有被执行。因为第一句`(a[0] < b)`已经可以确定整个式子的真值为真，不在需要后续的判断了。

### 3.2 循环

